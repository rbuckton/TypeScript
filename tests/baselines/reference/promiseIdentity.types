=== tests/cases/compiler/promiseIdentity.ts ===
interface IPromise1<T> {
>IPromise1 : IPromise1<T>
>T : T

    then<U>(callback: (x: T) => IPromise1<U>): IPromise1<U>;
>then : <U>(callback: (x: T) => IPromise1<U>) => IPromise1<U>
>U : U
>callback : (x: T) => IPromise1<U>
>x : T
>T : T
>IPromise1 : IPromise1<T>
>U : U
>IPromise1 : IPromise1<T>
>U : U
}
interface Promise1<T> {
>Promise1 : Promise1<T>
>T : T

    then<U>(callback: (x: T) => Promise1<U>): Promise1<U>;
>then : <U>(callback: (x: T) => Promise1<U>) => Promise1<U>
>U : U
>callback : (x: T) => Promise1<U>
>x : T
>T : T
>Promise1 : Promise1<T>
>U : U
>Promise1 : Promise1<T>
>U : U
}
var x: IPromise1<string>;
>x : IPromise1<string>
>IPromise1 : IPromise1<T>

var x: Promise1<string>;
>x : IPromise1<string>
>Promise1 : Promise1<T>


interface IPromise2<T, V> {
>IPromise2 : IPromise2<T, V>
>T : T
>V : V

    then<U, W>(callback: (x: T) => IPromise2<U, W>): IPromise2<W, U>;
>then : <U, W>(callback: (x: T) => IPromise2<U, W>) => IPromise2<W, U>
>U : U
>W : W
>callback : (x: T) => IPromise2<U, W>
>x : T
>T : T
>IPromise2 : IPromise2<T, V>
>U : U
>W : W
>IPromise2 : IPromise2<T, V>
>W : W
>U : U
}
interface Promise2<T, V> {
>Promise2 : Promise2<T, V>
>T : T
>V : V

    then<U, W>(callback: (x: V) => Promise2<U, T>): Promise2<T, W>; // Uses V instead of T in callback's parameter
>then : <U, W>(callback: (x: V) => Promise2<U, T>) => Promise2<T, W>
>U : U
>W : W
>callback : (x: V) => Promise2<U, T>
>x : V
>V : V
>Promise2 : Promise2<T, V>
>U : U
>T : T
>Promise2 : Promise2<T, V>
>T : T
>W : W
}

// Ok because T in this particular Promise2 is any, as are all the U and W references.
// Also, the V of Promise2 happens to coincide with the T of IPromise2 (they are both string).
var y: IPromise2<string, number>;
>y : IPromise2<string, number>
>IPromise2 : IPromise2<T, V>

var y: Promise2<any, string>;
>y : IPromise2<string, number>
>Promise2 : Promise2<T, V>

