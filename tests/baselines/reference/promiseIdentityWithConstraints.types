=== tests/cases/compiler/promiseIdentityWithConstraints.ts ===
interface IPromise1<T, V> {
>IPromise1 : IPromise1<T, V>
>T : T
>V : V

    then<U extends T, W extends V>(callback: (x: T) => IPromise1<U, W>): IPromise1<U, W>;
>then : <U extends T, W extends V>(callback: (x: T) => IPromise1<U, W>) => IPromise1<U, W>
>U : U
>T : T
>W : W
>V : V
>callback : (x: T) => IPromise1<U, W>
>x : T
>T : T
>IPromise1 : IPromise1<T, V>
>U : U
>W : W
>IPromise1 : IPromise1<T, V>
>U : U
>W : W
}
interface Promise1<T, V> {
>Promise1 : Promise1<T, V>
>T : T
>V : V

    then<U extends T, W extends V>(callback: (x: T) => Promise1<U, W>): Promise1<U, W>;
>then : <U extends T, W extends V>(callback: (x: T) => Promise1<U, W>) => Promise1<U, W>
>U : U
>T : T
>W : W
>V : V
>callback : (x: T) => Promise1<U, W>
>x : T
>T : T
>Promise1 : Promise1<T, V>
>U : U
>W : W
>Promise1 : Promise1<T, V>
>U : U
>W : W
}

// Error because constraint V doesn't match
var x: IPromise1<string, number>;
>x : IPromise1<string, number>
>IPromise1 : IPromise1<T, V>

var x: Promise1<string, boolean>;
>x : IPromise1<string, number>
>Promise1 : Promise1<T, V>

